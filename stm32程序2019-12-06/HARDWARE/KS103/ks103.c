#include "myiic.h"
#include "delay.h"




//产生IIC起始信号
void IIC_KS103_Start(void)
{
	SDA_OUT();     //sda线输出
	IIC_SDA=1;	  	  
	IIC_SCL=1;
	delay_us(10);
 	IIC_SDA=0;//START:when CLK is high,DATA change form high to low 
	delay_us(10);
	IIC_SCL=0;//钳住I2C总线，准备发送或接收数据 
}	  
//产生IIC停止信号
void IIC_KS103_Stop(void)
{
	SDA_OUT();//sda线输出
	IIC_SCL=0;
	IIC_SDA=0;//STOP:when CLK is high DATA change form low to high
 	delay_us(10);
	IIC_SCL=1; 
	IIC_SDA=1;//发送I2C总线结束信号
	delay_us(10);							   	
}
//等待应答信号到来
//返回值：1，接收应答失败
//        0，接收应答成功
u8 IIC_KS103_Wait_Ack(void)
{
	u8 ucErrTime=0;
	SDA_IN();      //SDA设置为输入  
	IIC_SDA=1;delay_us(6);	   
	IIC_SCL=1;delay_us(6);	 
	while(READ_SDA)
	{
		ucErrTime++;
		if(ucErrTime>250)
		{
			IIC_KS103_Stop();
			return 1;
		}
	}
	IIC_SCL=0;//时钟输出0 	   
	return 0;  
} 
//产生ACK应答
void IIC_KS103_Ack(void)
{
	IIC_SCL=0;
	SDA_OUT();
	IIC_SDA=0;
	delay_us(10);
	IIC_SCL=1;
	delay_us(10);
	IIC_SCL=0;
}
//不产生ACK应答		    
void IIC_KS103_NAck(void)
{
	IIC_SCL=0;
	SDA_OUT();
	IIC_SDA=1;
	delay_us(10);
	IIC_SCL=1;
	delay_us(10);
	IIC_SCL=0;
}					 				     
//IIC发送一个字节
//返回从机有无应答
//1，有应答
//0，无应答			  
void IIC_KS103_Send_Byte(u8 txd)
{                        
    u8 t;   
	SDA_OUT(); 	    
    IIC_SCL=0;//拉低时钟开始数据传输
    for(t=0;t<8;t++)
    {              
        IIC_SDA=(txd&0x80)>>7;
        txd<<=1; 	  
		delay_us(10);   //对TEA5767这三个延时都是必须的
		IIC_SCL=1;
		delay_us(10); 
		IIC_SCL=0;	
		delay_us(10);
    }	 
} 	    
//读1个字节，ack=1时，发送ACK，ack=0，发送nACK   
u8 IIC_KS103_Read_Byte(unsigned char ack)
{
	unsigned char i,receive=0;
	SDA_IN();//SDA设置为输入
    for(i=0;i<8;i++ )
	{
        IIC_SCL=0; 
        delay_us(10);
		IIC_SCL=1;
        receive<<=1;
        if(READ_SDA)receive++;   
		delay_us(5); 
    }					 
    if (!ack)
        IIC_KS103_NAck();//发送nACK
    else
        IIC_KS103_Ack(); //发送ACK   
    return receive;
}
u8 KS103_ReadOneByte(u8 address, u8 reg)
{
u8 temp=0;
IIC_KS103_Start();
IIC_KS103_Send_Byte(address); //?????
IIC_KS103_Wait_Ack();
IIC_KS103_Send_Byte(reg); //?????
IIC_KS103_Wait_Ack();
IIC_KS103_Start();
IIC_KS103_Send_Byte(address + 1); //??????
IIC_KS103_Wait_Ack();
delay_us(100); //?????????!!!
temp=IIC_KS103_Read_Byte(0); //????3
IIC_KS103_Stop();//????????
return temp;
}


void KS103_WriteOneByte(u8 address,u8 reg,u8 command)
{
IIC_KS103_Start();
IIC_KS103_Send_Byte(address); //?????
IIC_KS103_Wait_Ack();
IIC_KS103_Send_Byte(reg);//?????
IIC_KS103_Wait_Ack();
IIC_KS103_Send_Byte(command); //?????
IIC_KS103_Wait_Ack();
IIC_KS103_Stop();//????????
}


u16 detect(u8 address,u8 command) //0xe8(address) + 0xb0(command)
{
u16 distance=0;
KS103_WriteOneByte(address,0X02,command);
//delay_ms(80);
	delay_ms(50);
	//while(!IIC_SCL);
distance = KS103_ReadOneByte(address, 0x02);
distance <<= 8;
distance += KS103_ReadOneByte(address, 0x03);
return distance; //return 16 bit distance in millimeter
}

void KS103_change_address(u8 old_address,u8 new_address)
{
//delay_ms(2000); // Protect the eeprom ,you can delete this sentence
KS103_WriteOneByte(old_address,2,0x9a);
delay_ms(1);
KS103_WriteOneByte(old_address,2,0x92);
delay_ms(1);
KS103_WriteOneByte(old_address,2,0x9e);
delay_ms(1);
KS103_WriteOneByte(old_address,2, new_address);
delay_ms(100);
}
